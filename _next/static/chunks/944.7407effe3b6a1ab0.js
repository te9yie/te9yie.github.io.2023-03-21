"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[944],{1944:function(n,e,c){c.r(e);var o;e.default={setup:function(n,e){n.createCanvas(320,180,n.WEBGL).parent(e),o=n.createShader("\nprecision mediump float;\nattribute vec3 aPosition;\n\nvoid main() {\n  gl_Position = vec4(aPosition, 1.0);\n}","\nprecision mediump float;\nuniform float uTime;\nuniform vec2 uResolution;\n\nconst float PI = 3.14159265;\nconst float angle = 60.0;\nconst float fov = angle * 0.5 * PI / 180.0;\nconst vec3 light_dir = normalize(vec3(-1, 1, 1));\n\nvec3 trans(vec3 p) {\n  return mod(p, 3.0) - 1.5;\n}\n\nfloat sphere(vec3 p, float r) {\n  return length(trans(p)) - r;\n}\n\nfloat calc(vec3 p) {\n  return sphere(p, 1.0);\n}\n\nvec3 calc_normal(vec3 p) {\n  float d = 0.0001;\n  return normalize(vec3(\n    calc(p + vec3(d, 0, 0)) - calc(p - vec3(d, 0, 0)),\n    calc(p + vec3(0, d, 0)) - calc(p - vec3(0, d, 0)),\n    calc(p + vec3(0, 0, d)) - calc(p - vec3(0, 0, d))));\n}\n\nvoid main() {\n  vec2 p = (gl_FragCoord.xy * 2.0 - uResolution) / min(uResolution.x, uResolution.y);\n  vec3 eye = vec3(sin(uTime * 0.5), cos(uTime * 0.3) * 0.7, 3);\n  vec3 ray = normalize(vec3(sin(fov) * p.x, sin(fov) * p.y, -cos(fov)));\n\n  float distance = 0.0;\n  float len = 0.0;\n  vec3 pos = eye;\n  for (int i = 0; i < 64; ++i) {\n    distance = calc(pos);\n    len += distance;\n    pos = eye + ray * len;\n  }\n\n  if (abs(distance) < 0.001) {\n    vec3 n = calc_normal(pos);\n    float diff = clamp(dot(light_dir, n), 0.1, 1.0);\n    gl_FragColor = vec4(vec3(diff), 1);\n  } else {\n    gl_FragColor = vec4(vec3(0), 1);\n  }\n}")},draw:function(n){o.setUniform("uTime",n.frameCount/30),o.setUniform("uResolution",[320,180]),n.shader(o),n.quad(-1,1,-1,-1,1,-1,1,1),n.resetShader()}}}}]);